package pt.ipp.isep.dei.performance.export;

import pt.ipp.isep.dei.performance.PerformanceResult;
import pt.ipp.isep.dei.performance.TestScenario;
import pt.ipp.isep.dei.performance.core.PerformanceTestConfig;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Generates analysis reports and summaries from performance test results.
 * Creates human-readable reports with statistical analysis and insights.
 */
public class ReportGenerator {
    
    /**
     * Generates a comprehensive summary report with statistical analysis.
     * 
     * @param allResults all performance results from both algorithms
     * @param scenarios the test scenarios that were executed
     * @throws IOException if report writing fails
     */
    public void generateSummaryReport(List<PerformanceResult> allResults, List<TestScenario> scenarios) throws IOException {
        ensureOutputDirectoryExists();
        
        try (FileWriter writer = new FileWriter(PerformanceTestConfig.getOutputFilePath(
                PerformanceTestConfig.SUMMARY_REPORT_FILE).toFile())) {
            
            writeReportHeader(writer);
            writeExecutionSummary(writer, allResults, scenarios);
            writeAlgorithmAnalysis(writer, allResults);
            writeDetailedResults(writer, allResults);
            writeReportFooter(writer);
        }
    }
    
    /**
     * Writes the report header with execution information.
     * 
     * @param writer the file writer
     * @throws IOException if writing fails
     */
    private void writeReportHeader(FileWriter writer) throws IOException {
        writer.write("US29 Performance Analysis Summary\n");
        writer.write("================================\n\n");
        writer.write("Test Execution Date: " + LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) + "\n");
        writer.write("Generated by: US29 Performance Test Framework\n\n");
    }
    
    /**
     * Writes execution summary with high-level statistics.
     * 
     * @param writer the file writer
     * @param allResults all performance results
     * @param scenarios the test scenarios
     * @throws IOException if writing fails
     */
    private void writeExecutionSummary(FileWriter writer, List<PerformanceResult> allResults, 
                                     List<TestScenario> scenarios) throws IOException {
        writer.write("Execution Summary\n");
        writer.write("================\n");
        writer.write("Total Scenarios Available: " + scenarios.size() + "\n");
        writer.write("Total Test Results: " + allResults.size() + "\n");
        
        Map<String, List<PerformanceResult>> resultsByAlgorithm = allResults.stream()
            .collect(Collectors.groupingBy(PerformanceResult::getAlgorithm));
        
        for (Map.Entry<String, List<PerformanceResult>> entry : resultsByAlgorithm.entrySet()) {
            writer.write("Results for " + entry.getKey() + ": " + entry.getValue().size() + "\n");
        }
        
        long validResults = allResults.stream().filter(r -> r.getExecutionTimeMs() > 0).count();
        long errorResults = allResults.size() - validResults;
        
        writer.write("Valid Results: " + validResults + "\n");
        writer.write("Error Results: " + errorResults + "\n");
        
        if (!allResults.isEmpty()) {
            writeInputSizeAnalysis(writer, allResults);
        }
        
        writer.write("\n");
    }
    
    /**
     * Writes input size analysis.
     * 
     * @param writer the file writer
     * @param results all performance results
     * @throws IOException if writing fails
     */
    private void writeInputSizeAnalysis(FileWriter writer, List<PerformanceResult> results) throws IOException {
        List<Integer> inputSizes = results.stream()
            .mapToInt(PerformanceResult::getInputSize)
            .distinct()
            .sorted()
            .boxed()
            .collect(Collectors.toList());
        
        if (!inputSizes.isEmpty()) {
            writer.write("Input Size Range: " + inputSizes.get(0) + " - " + inputSizes.get(inputSizes.size() - 1) + "\n");
            writer.write("Different Input Sizes Tested: " + inputSizes.size() + "\n");
        }
    }
    
    /**
     * Writes detailed analysis for each algorithm.
     * 
     * @param writer the file writer
     * @param allResults all performance results
     * @throws IOException if writing fails
     */
    private void writeAlgorithmAnalysis(FileWriter writer, List<PerformanceResult> allResults) throws IOException {
        Map<String, List<PerformanceResult>> resultsByAlgorithm = allResults.stream()
            .collect(Collectors.groupingBy(PerformanceResult::getAlgorithm));
        
        for (Map.Entry<String, List<PerformanceResult>> entry : resultsByAlgorithm.entrySet()) {
            String algorithm = entry.getKey();
            List<PerformanceResult> results = entry.getValue();
            
            writer.write(algorithm + " Algorithm Analysis\n");
            writer.write("=".repeat(algorithm.length() + 18) + "\n");
            
            if (results.isEmpty()) {
                writer.write("No results collected for " + algorithm + ".\n\n");
                continue;
            }
            
            writeAlgorithmStatistics(writer, results);
            writePerformanceInsights(writer, results);
            writer.write("\n");
        }
    }
    
    /**
     * Writes statistical analysis for a specific algorithm.
     * 
     * @param writer the file writer
     * @param results results for the algorithm
     * @throws IOException if writing fails
     */
    private void writeAlgorithmStatistics(FileWriter writer, List<PerformanceResult> results) throws IOException {
        List<PerformanceResult> validResults = results.stream()
            .filter(r -> r.getExecutionTimeMs() > 0)
            .collect(Collectors.toList());
        
        long successCount = results.stream().filter(PerformanceResult::isSuccess).count();
        
        writer.write("Scenarios Tested: " + results.size() + "\n");
        writer.write("Successful Executions: " + successCount + 
                   String.format(" (%.1f%%)\n", (successCount * 100.0) / results.size()));
        writer.write("Valid Timing Results: " + validResults.size() + "\n");
        
        if (!validResults.isEmpty()) {
            List<Double> executionTimes = validResults.stream()
                .map(PerformanceResult::getExecutionTimeMs)
                .collect(Collectors.toList());
            
            double minTime = executionTimes.stream().mapToDouble(Double::doubleValue).min().orElse(0.0);
            double maxTime = executionTimes.stream().mapToDouble(Double::doubleValue).max().orElse(0.0);
            double avgTime = executionTimes.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);
            
            List<Integer> inputSizes = validResults.stream()
                .mapToInt(PerformanceResult::getInputSize)
                .sorted()
                .boxed()
                .collect(Collectors.toList());
            
            writer.write(String.format("Execution Time (ms) - Min: %.3f, Max: %.3f, Avg: %.3f\n", 
                                     minTime, maxTime, avgTime));
            
            if (!inputSizes.isEmpty()) {
                writer.write("Input Size Range: " + inputSizes.get(0) + " - " + 
                           inputSizes.get(inputSizes.size() - 1) + "\n");
            }
        }
    }
    
    /**
     * Writes performance insights and complexity estimates.
     * 
     * @param writer the file writer
     * @param results results for the algorithm
     * @throws IOException if writing fails
     */
    private void writePerformanceInsights(FileWriter writer, List<PerformanceResult> results) throws IOException {
        List<PerformanceResult> validResults = results.stream()
            .filter(r -> r.getExecutionTimeMs() > 0)
            .sorted((r1, r2) -> Integer.compare(r1.getInputSize(), r2.getInputSize()))
            .collect(Collectors.toList());
        
        if (validResults.size() < 2) {
            writer.write("Insufficient data for complexity analysis.\n");
            return;
        }
        
        writer.write("Performance Insights:\n");
        
        // Analyze efficiency trend
        PerformanceResult smallest = validResults.get(0);
        PerformanceResult largest = validResults.get(validResults.size() - 1);
        
        double efficiencyRatioSmallest = smallest.getEfficiencyRatio();
        double efficiencyRatioLargest = largest.getEfficiencyRatio();
        
        if (efficiencyRatioLargest < efficiencyRatioSmallest * 0.5) {
            writer.write("- Performance degrades significantly with input size (possible O(n²) or higher)\n");
        } else if (efficiencyRatioLargest < efficiencyRatioSmallest * 0.8) {
            writer.write("- Performance degrades moderately with input size (possible O(n log n))\n");
        } else {
            writer.write("- Performance scales well with input size (possible O(n) or O(log n))\n");
        }
        
        // Complexity category distribution
        Map<String, Long> categoryCount = validResults.stream()
            .collect(Collectors.groupingBy(PerformanceResult::getComplexityCategory, Collectors.counting()));
        
        writer.write("- Test coverage by complexity: ");
        categoryCount.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .forEach(entry -> {
                try {
                    writer.write(entry.getKey() + "(" + entry.getValue() + ") ");
                } catch (IOException e) {
                    // Ignore write errors in lambda
                }
            });
        writer.write("\n");
    }
    
    /**
     * Writes detailed results for all algorithms.
     * 
     * @param writer the file writer
     * @param allResults all performance results
     * @throws IOException if writing fails
     */
    private void writeDetailedResults(FileWriter writer, List<PerformanceResult> allResults) throws IOException {
        if (allResults.isEmpty()) {
            return;
        }
        
        writer.write("Detailed Results\n");
        writer.write("================\n");
        
        Map<String, List<PerformanceResult>> resultsByAlgorithm = allResults.stream()
            .collect(Collectors.groupingBy(PerformanceResult::getAlgorithm));
        
        for (Map.Entry<String, List<PerformanceResult>> entry : resultsByAlgorithm.entrySet()) {
            String algorithm = entry.getKey();
            List<PerformanceResult> results = entry.getValue();
            
            writer.write("\n" + algorithm + " Results:\n");
            
            List<PerformanceResult> sortedResults = results.stream()
                .sorted((r1, r2) -> Integer.compare(r1.getInputSize(), r2.getInputSize()))
                .collect(Collectors.toList());
            
            for (PerformanceResult result : sortedResults) {
                writer.write("  " + result.toSummaryString() + "\n");
            }
        }
    }
    
    /**
     * Writes the report footer with additional information.
     * 
     * @param writer the file writer
     * @throws IOException if writing fails
     */
    private void writeReportFooter(FileWriter writer) throws IOException {
        writer.write("\nNotes:\n");
        writer.write("======\n");
        writer.write("- All execution times are averaged over " + PerformanceTestConfig.DEFAULT_TEST_RUNS + " runs\n");
        writer.write("- Negative execution times indicate errors during testing\n");
        writer.write("- Efficiency ratio = input size / execution time (higher is better)\n");
        writer.write("- Complexity categories: SMALL(≤50), MEDIUM(≤200), LARGE(≤500), EXTRA_LARGE(≤1000), MASSIVE(>1000)\n");
    }
    
    /**
     * Ensures the output directory exists.
     * 
     * @throws IOException if directory creation fails
     */
    private void ensureOutputDirectoryExists() throws IOException {
        Files.createDirectories(PerformanceTestConfig.getOutputPath());
    }
}